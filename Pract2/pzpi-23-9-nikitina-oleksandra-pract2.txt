Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук
Кафедра програмної інженерії


ЗВІТ
до практичного завдання №2
з дисципліни «Аналіз та рефакторинґ коду»
на тему: «Методи рефакторингу коду програмного забезпечення: Consolidate Conditional Expression, Replace Method with Method Object, Replace Constructor with Factory Method у мові С#»


Виконала
ст. гр. ПЗПІ-23-9
Нікітіна Олександра

Перевірив
ст. викладач катедри ПІ
Сокорчук Ігор Петрович


Харків 2025
ЗМІСТ
1 ІСТОРІЯ ЗМІН	4
2 ЗАВДАННЯ	5
3 ОПИС ВИКОНАНОЇ РОБОТИ	6
3.1 Вступ	6
3.2 Вибір методів рефакторингу	6
3.3 Метод 1: Consolidate Conditional Expression (Об'єднання умовних виразів)	7
3.3.1 Опис проблеми	7
3.3.2 Суть методу	7
3.3.3 Код до рефакторингу	8
3.3.4 Пояснення обраного методу	8
3.3.6 Переваги отриманого коду після застосування методу	9
3.4 Метод 2: Replace Method with Method Object (Заміна методу об'єктом-методом)	9
3.4.1 Опис проблеми	9
3.4.2 Суть методу	9
3.4.3 Код до рефакторингу	10
3.4.4 Пояснення обраного методу	10
3.4.6 Переваги отриманого коду після застосування методу	12
3.5 Метод 3: Replace Constructor with Factory Method (Заміна конструктора фабричним методом)	12
3.5.1 Опис проблеми	12
3.5.2 Суть методу	12
3.5.3 Код до рефакторингу	12
3.5.4 Пояснення обраного методу	13
3.5.6 Переваги отриманого коду після застосування методу	13
3.6 Інструменти автоматизації рефакторингу (Visual Studio)	14
3.6.1 Меню «Quick Actions» (Швидкі дії)	14
3.6.2 Безпечне перейменування (Rename)	14
3.6.3 Move to File / Move Type to File	14
3.6.4 Extract Interface / Extract Base Class	15
3.6.5 Remove Unused Usings та автоматичне форматування	15
3.6.6 Вбудований аналізатор коду (Code Analysis)	15
3.7 Висновок	15
4 ВИСНОВКИ	16
5 ВИКОРИСТАНІ ДЖЕРЕЛА	17
ДОДАТОК А Відеозапис	18
ДОДАТОК Б Слайди презентації	19
ДОДАТОК В Програмний код	27




1 ІСТОРІЯ ЗМІН
№ДатаВерсія звітуОпис змін та виправлень125.11.20250.1Створено усі розділи: «Завдання», «Опис виконаної роботи», «Використані джерела», «Висновки», «Додаток А», «Додаток Б», «Додаток В».


2 ЗАВДАННЯ
1. Студент повинен обрати три методи рефакторингу коду із книги Мартіна Фаулера «Refactoring. Improving the Design of Existing Code».
2. Навести приклади свого особистого коду (з курсових, лабораторних або інших проєктів), який потребує покращення, та продемонструвати застосування обраних методів.
3. Кожен метод рефакторингу повинен супроводжуватись:
• Описом проблеми, яку вирішує даний метод.
• Кодом до і після застосування методу рефакторингу.
• Поясненням переваг використаного методу.

3 ОПИС ВИКОНАНОЇ РОБОТИ
     3.1 Вступ
     У світі розробки існує відомий вислів: «Будь-який дурень може написати код, зрозумілий комп'ютеру. Гарний програміст пише код, зрозумілий людині». Цю фразу Мартін Фаулер зробив лейтмотивом своєї книги «Refactoring. Improving the Design of Existing Code», яка і стала теоретичною основою моєї роботи.
     Ми всі знаємо, що написати програму, яка просто працює – це лише половина справи. Набагато складніше написати код, який буде зрозумілим для інших розробників і який легко змінювати в майбутньому.
     Взагалі, що таке рефакторинг? Це процес зміни внутрішньої структури програми без зміни її зовнішньої поведінки. Його мета: не додати нову фічу, а зробити код чистішим, зрозумілішим та дешевшим у підтримці.
     Перш ніж переходити до методів, варто пояснити, коли саме нам потрібен рефакторинг. Фаулер вводить чудовий термін – «Запахи коду» (Code Smells). Уявіть, що ви заходите на кухню і відчуваєте неприємний запах. Ви ще не бачите зіпсованих продуктів, але вже розумієте: щось не так. Так само і в коді: програма може працювати без помилок, компілюватися, але її структура «попахує». Це може бути занадто довгий метод, дублювання рядків або заплутані умови. Саме ці «запахи» сигналізують нам, що настав час для «лікування» коду – тобто рефакторингу.
     3.2 Вибір методів рефакторингу
     Для практичної частини я обрала свій курсовий проєкт першого курсу – гру Boulder Dash. Переглянувши його зараз, я знайшла типові «запахи коду» і застосувала три методи для їх усунення:
1. Consolidate Conditional Expression (Об'єднання умовних виразів).
2. Replace Method with Method Object (Заміна методу об'єктом-методом).
3. Replace Constructor with Factory Method (Заміна конструктора фабричним методом).
     3.3 Метод 1: Consolidate Conditional Expression (Об'єднання умовних виразів)
     3.3.1 Опис проблеми
     Перша проблема, з якою стикаються майже всі новачки – це складні перевірки. Часто буває так, що нам треба перевірити кілька умов, і якщо хоча б одна з них істинна – ми виконуємо одну й ту ж дію (наприклад, вихід з функції або повернення false). Фаулер називає це «фрагментацією умов». 
     У коді це часто виглядає як «сходинки» з операторів if. Програмісти називають це «Arrow Code» (Ефект стріли), тому що код через відступи зміщується вправо і візуально нагадує вістря стріли. Такий код дуже важко читати – доводиться постійно тримати в голові контекст попередніх умов.
     Подивимося на простий приклад
     Уявіть перепустку на атракціон.
• якщо зріст менше 120 см – вхід заборонено;
• якщо вага менше 30 кг – вхід заборонено;
• якщо є серцеві хвороби – вхід заборонено.
     Замість трьох окремих перевірок, ми можемо сказати однією фразою: «Якщо є будь-яка з фізичних перешкод – вхід заборонено».
     3.3.2 Суть методу
     Суть методу Consolidate Conditional Expression – це об'єднати всі перевірки в один вираз, використовуючи логічні оператори «І» (&&) та «АБО» (||), або винести їх у окремий метод із промовистою назвою.
     
     
     
     3.3.3 Код до рефакторингу
     У моїй грі була аналогічна ситуація в методі переміщення гравця (MovePlayer). Мені потрібно було перевірити, чи може гравець штовхнути камінь.
     Як це виглядало ДО? Подивіться на фрагмент коду нижче. Я спочатку перевіряла, чи не виходять координати за межі карти. Потім, всередині цього блоку, відкривала новий if, щоб перевірити, чи пуста клітинка за каменем.
     
1 int newElementX = newPlayerX + changeX;
2 int newElementY = newPlayerY + changeY;
3 
4 // "Ефект стріли" - вкладені умови
5 // Перша перевірка: чи не виходимо за межі
6 if (map.IsInside(newElementX, newElementY))
7 {
8     Element stoneDestination = map[newElementX, newElementY];
9     // Друга перевірка: чи є місце для каменя
10     if (stoneDestination.IsEmpty())
11     {
12         map[newElementX, newElementY] = map[newPlayerX, newPlayerY];
13         map[player.X, player.Y] = new Emptiness(map);
14         player.X = newPlayerX;
15         player.Y = newPlayerY;
16         map[player.X, player.Y] = player;
17     }
18 }
     
     3.3.4 Пояснення обраного методу
     Це класичний приклад надлишкової вкладеності. Хоча логічно ці дві умови є частинами одного питання: «Чи є місце для штовхання?».
     Тому я застосувала метод Consolidate Conditional Expression. Я об'єднала ці дві перевірки в одну лінію, використовуючи логічний оператор «І» (&&).
     3.3.5 Код після рефакторингу
1 int pushX = newPlayerX + changeX;
2 int pushY = newPlayerY + changeY;
3 
4 // Умова читається в один рядок
5 if (map.IsInside(pushX, pushY) && map[pushX, pushY].IsEmpty())
6 {
7     map[pushX, pushY] = map[newPlayerX, newPlayerY];
8     map[player.X, player.Y] = new Emptiness(map);
9     player.X = newPlayerX;
10     player.Y = newPlayerY;
11     map[player.X, player.Y] = player;
12 }
     
     3.3.6 Переваги отриманого коду після застосування методу
     Після рефакторингу було отримано дві переваги:
1. Читабельність: Код став лінійним, ми позбулися зайвого рівня вкладеності.
2. Чіткість намірів: Тепер зрозуміло, що ці дві умови є нерозривними для виконання дії.
     3.4 Метод 2: Replace Method with Method Object (Заміна методу об'єктом-методом)
     3.4.1 Опис проблеми
     Це один із найпотужніших методів рефакторингу. Він використовується для боротьби з так званими «Божественними методами» (God Method). «Божественний метод» – це функція, яка знає занадто багато і робить занадто багато. Вона може мати 100-200 рядків коду і купу локальних змінних.
     Чому це погано? Такий метод неможливо просто розбити на менші частини. Якщо спробувати виділити шматок коду в під-метод, то доведеться передавати туди 10 параметрів (всі ці локальні змінні), що зробить код ще гіршим.
     3.4.2 Суть методу
     Суть методу Replace Method with Method Object в тому, що ми перетворюємо цей метод на окремий клас. Локальні змінні стають полями цього класу. А сам код методу розбивається на маленькі методи всередині цього нового класу.
     3.4.3 Код до рефакторингу
     У моєму проєкті метод GameProcess у класі Game був саме таким. Він керував усім: запускав ігровий цикл while, обробляв натискання клавіш, прораховував гравітацію і малював карту. 
     Як це виглядало ДО? Уся логіка була звалена в купу. Змінні жили в одному просторі, і було важко зрозуміти, де закінчується обробка кнопок і починається фізика гри.
     
1 public void GameProcess()
2 {
3     // Купа локальних змінних, які важко контролювати
4     Stopwatch stopwatch = new Stopwatch();
5     stopwatch.Start();
6     Program.CurrentGameState = GameState.Running;
7 
8     // Гігантський цикл, де намішано все
9     while (Program.CurrentGameState == GameState.Running)
10     {
11         // 1. Блок обробки клавіш 
12         var key = Console.ReadKey(true);
13         // ... тут 50 рядків if/else для руху гравця ...
14 
15         // 2. Блок фізики 
16         for (int i = map.Height - 2; i >= 0; i--) {
17         // ... тут складна логіка падіння каміння ...
18         }
19 
20         // 3. Блок малювання
21         Console.Clear();
22         PrintMap();
23     }
24 }
     
     3.4.4 Пояснення обраного методу
     Що я зробила:
1) створила новий клас GameEngine;
2) змінні map, player, message стали полями цього класу;
3) велетенський цикл розбила на методи HandleInput, UpdatePhysics, Render.
     3.4.5 Код після рефакторингу
     Тепер у головному класі Game залишився лише виклик:
     
1 public void GameProcess()
2 {
3     Console.Clear();
4     Stopwatch stopwatch = new Stopwatch();
5     stopwatch.Start();
6     Program.CurrentGameState = GameState.Running;
7 
8     // Використання Method Object
9     GameEngine engine = new GameEngine(map, player);
10     engine.Run();
11 
12     stopwatch.Stop();
13     // ... повідомлення про кінець гри ...
14 }
     
     А всередині нового класу логіка стала чистою:
     
1 class GameEngine 
2 {
3     private Map _map;
4     private Player _player;
5 
6     public GameEngine(Map map, Player player) { ... }
7 
8     public void Run() 
9     {
10         while (Program.CurrentGameState == GameState.Running) 
11         {
12             HandleInput();   
13             UpdatePhysics(); 
14             Render();        
15         }
16     }
17     // ... реалізація приватних методів ...
18 }
     
     
     
     3.4.6 Переваги отриманого коду після застосування методу
     Було ізольовано складну логіку: величезний алгоритм розбито на зрозумілі кроки.  Локальні змінні більше не передаються параметрами, вони доступні всім методам класу GameEngine як поля. Це робить код структурованим і легким для підтримки.
     3.5 Метод 3: Replace Constructor with Factory Method (Заміна конструктора фабричним методом)
     3.5.1 Опис проблеми
     Третій метод стосується створення об'єктів. У мові C# ми звикли створювати об'єкти через оператор new. Але коли ми пишемо new Diamond(), ми жорстко прив'язуємо наш код до конкретного класу. Це називається жорстка зв'язність (High Coupling). Клас повинен знати точне ім'я класу, який він створює. Якщо нам знадобиться поліморфізм (створювати різні типи алмазів залежно від умов), доведеться переписувати код у багатьох місцях. 
     Крім того, конструктор завжди має називатися так само як клас. Ми не можемо назвати його CreateRedDiamond чи CreateBonusDiamond. А Фабричний метод – може мати будь-яку зрозумілу назву.
     3.5.2 Суть методу
     Суть методу Replace Constructor with Factory Method – замінити прямий виклик конструктора на виклик статичного методу, який повертає екземпляр класу.
     3.5.3 Код до рефакторингу
     У моїй грі є цікава механіка: є клас Jewel – це необроблене коштовне каміння. Коли на нього падає звичайний камінь, Jewel розбивається і перетворюється на готовий до збору великий діамант (BigDiamond).
     Як це виглядало ДО:
     
1 // Уривок з методу Gravity
2 else if (belowElement is Jewel)
3 {
4     // Жорстка прив'язка: 
5     // ми "знаємо", що Jewel завжди дає BigDiamond.
6     // Це погано для розширення.
7     map[newElementX, newElementY] = new BigDiamond(map);
8     map[i, j] = new Emptiness(map);
9 }
     
     3.5.4 Пояснення обраного методу
     Тут є проблема розширення. Якщо я в майбутньому додам різні види Jewel (наприклад, RareJewel, BlueJewel), мені доведеться писати тут купу if-else, щоб вирішувати, чи створювати звичайний Diamond чи BigDiamond.
     І тому я замінила прямий виклик конструктора на Фабричний метод. Тепер клас Game не вирішує, у що перетвориться камінь – це вирішує Фабрика.
     3.5.5 Код після рефакторингу
1 else if (belowElement is Jewel)
2 {
3     // Виклик Фабричного методу
4     map[newElementX, newElementY] = ElementFactory.CreateTransformedJewel(map, belowElement);
5     map[i, j] = ElementFactory.CreateEmptiness(map);
6 }
     
     3.5.6 Переваги отриманого коду після застосування методу
     Це дає величезну гнучкість для розвитку гри. Я можу додати нові типи Jewel, які будуть перетворюватися на різні види діамантів (звичайні, великі, бонусні), і мені не доведеться змінювати код фізики (Gravity). Вся логіка «яка руда дає який діамант» буде знаходитися в одному місці – у Фабриці.
     Також було зменшено зв’язність, бо основна логіка гри тепер менше залежить від деталей реалізації конкретних блоків.
     3.6 Інструменти автоматизації рефакторингу (Visual Studio)
     Виконувати рефакторинг вручну (просто переписуючи текст) – це корисно для навчання, але довго і небезпечно, бо можна легко зробити помилку або одруківку. В реальній роботі краще використовувати спеціальні інструменти.
     Саме тому сучасні середовища розробки пропонують автоматизовані інструменти, які роблять рефакторинг швидким, точним і безпечним.
     У моїй роботі я користувалася середовищем Visual Studio, і воно має потужну вбудовану систему підказок і автоматичних перетворень коду. Найбільш корисні можливості розглянуті нижче.
     3.6.1 Меню «Quick Actions» (Швидкі дії)
     Це головний механізм рефакторингу у Visual Studio. За допомогою комбінації Ctrl + . середовище показує контекстні підказки, які саме зараз можна застосувати до виділеного фрагмента коду.
     Наприклад, через Quick Actions можна виконувати Extract Method. Просто потрібно виділити частину логіки, і Visual Studio автоматично створює новий метод, сама визначає, які параметри потрібно передати, і акуратно замінює виділений код на виклик нового методу.
     3.6.2 Безпечне перейменування (Rename)
     Замість того, щоб вручну шукати і замінювати назву змінної (що може призвести до помилок, якщо імена схожі), можна використовувати функцію Rename (клавіша F2 або Ctrl+R, R). Вона змінює назву змінної чи методу одразу у всьому проєкті, інтелектуально розпізнаючи контекст.
     3.6.3 Move to File / Move Type to File
     Коли клас або інтерфейс знаходиться не в тому файлі, де мав би бути, Visual Studio пропонує автоматично перенести його в окремий файл.
     3.6.4 Extract Interface / Extract Base Class
     Visual Studio може автоматично створювати інтерфейс або базовий клас на основі вже існуючого класу.
     3.6.5 Remove Unused Usings та автоматичне форматування
     IDE автоматично підсвічує та видаляє непотрібні using-директиви, а також може вирівнювати відступи, розставляти фігурні дужки та упорядковувати поля класів.
     3.6.6 Вбудований аналізатор коду (Code Analysis)
     Visual Studio аналізує код у реальному часі та пропонує:
• замінити громіздкі конструкції на більш лаконічні;
• уникнути дублювання;
• попередити про можливі помилки або дурні місця;
• запропонувати оптимальніші варіанти коду.
     Це свого роду «автоматичний рев’юер», який забезпечує якість коду ще до запуску програми.
     3.7 Висновок
     Рефакторинг – це не просто «прибирання» в коді. Це інвестиція в майбутнє проєкту. Витрачаючи час зараз на чистку коду, ми економимо години налагодження у майбутньому.
     Обрані методи (Method Object, Consolidate Conditional, Factory Method) дозволили перетворити процедурний стиль написання гри на більш об'єктно-орієнтований та модульний. Завдяки використаним методам мій код позбувся дублювання та став зрозумілішим для читання. І хоча функціонал гри не змінився, її внутрішня якість значно зросла.


4 ВИСНОВКИ
     У ході виконання практичної роботи я не просто застосувала кілька методів рефакторингу, а глибше зрозуміла саму ідею покращення існуючого коду. Працюючи з власними прикладами я змогла побачити типові проблеми, які часто виникають під час розробки: надто довгі методи, дублювання логіки, незручні назви змінних або заплутані умовні конструкції. Це дало можливість оцінити, як подібні недоліки ускладнюють читання, підтримку та розвиток програмного забезпечення.
     Застосування методів рефакторингу за Фаулером показало, що навіть невеликі зміни можуть суттєво покращити структуру коду. Методи рефакторингу допомогли зробити код більш компактним, логічно поділеним і зрозумілим. Під час роботи я переконалася, що рефакторинг – це не просто механічне переписування, а процес, який змушує аналізувати код, шукати приховані проблеми й обирати оптимальні способи їх усунення.
     Окремо хочу відзначити важливість автоматизації. Використовуючи можливості Visual Studio для рефакторингу, я побачила, наскільки ці інструменти спрощують роботу та зменшують ризик помилок. Вони дозволяють зосередитись саме на покращенні логіки коду, а не на технічних деталях переписування.
     Загалом, виконана робота допомогла мені систематизувати знання про методи рефакторингу, навчила знаходити та виправляти недоліки у своїх програмах і сформувала більш професійний підхід до написання чистого та підтримуваного коду. Я зрозуміла, що рефакторинг – це не разова дія, а постійний елемент розробки, який підвищує якість програмного забезпечення і робить роботу розробника значно ефективнішою.
     

5 ВИКОРИСТАНІ ДЖЕРЕЛА
1. Fowler, M. Refactoring. Improving the Design of Existing Code. – Boston : Addison-Wesley, 2018.
2. Replace Method with Method Object [Електронний ресурс]. – Режим доступу: https://refactoring.guru/uk/replace-method-with-method-object (дата звернення: 25.11.2025).
3. Consolidate Conditional Expression [Електронний ресурс]. – Режим доступу: https://refactoring.guru/uk/consolidate-conditional-expression (дата звернення: 25.11.2025).
4. Replace Constructor with Factory Method [Електронний ресурс]. – Режим доступу: https://refactoring.guru/uk/replace-constructor-with-factory-method (дата звернення: 25.11.2025).
5. Microsoft. Code Analysis and Refactoring in Visual Studio [Електронний ресурс]. – Режим доступу: https://learn.microsoft.com/en-us/visualstudio/code-quality/code-analysis-and-refactoring (дата звернення: 25.11.2025).


ДОДАТОК А
Відеозапис
     Відеозапис доповіді: https://youtu.be/q7xCm9oALYk
     Хронологічний опис відеозапису:
00:00 - Вступ. Тема доповіді 
00:21 - Теоретична основа: Мартін Фаулер та книга «Refactoring» 
00:40 - Що таке рефакторинг та його цілі 
01:06 - Поняття «Запахи коду» (Code Smells) 
01:40 - Огляд методів на прикладі курсового проєкту (гра Boulder Dash) 
02:11 - Проблема №1: Складні перевірки та «Arrow Code» 
03:11 - Метод 1: Consolidate Conditional Expression (Об'єднання умовних виразів) 
04:19 - Проблема №2: «Божественний метод» (God Method) 
04:55 - Метод 2: Replace Method with Method Object (Заміна методу об'єктом-методом) 
05:12 - Практичний приклад рефакторингу GameProcess 
06:02 - Проблема №3: Жорстка зв'язність при створенні об'єктів (High Coupling) 
06:46 - Метод 3: Replace Constructor with Factory Method (Заміна конструктора фабричним методом) 
07:37 - Інструменти автоматизації рефакторингу у Visual Studio 
08:09 - Використання Quick Actions (Extract Method, Rename) 
09:05 - Додаткові інструменти (Move to file, Extract Interface, Remove Unused Usings) 
09:46 - Вбудований аналізатор коду (Code Analysis) 
10:15 - Висновки
10:48 - Список використаних джерел


ДОДАТОК Б
Слайди презентації

Рисунок Б.1 – Титульний слайд


Рисунок Б.2 – Вступ


Рисунок Б.3 – Що таке рефакторинг


Рисунок Б.4 – Перелік розглянутих методів рефакторингу


Рисунок Б.5 – Проблема 1 


Рисунок Б.6 – Простий приклад проблеми


Рисунок Б.7 – Метод 1: Consolidate Conditional Expression (Об'єднання умовних виразів)


Рисунок Б.8 – Проблема 2


Рисунок Б.9 – Метод 2: Replace Method with Method Object (Заміна методу об'єктом-методом)


Рисунок Б.10 – Приклад використання другого методу


Рисунок Б.11 – Проблема 3


Рисунок Б.12 – Метод 3: Replace Constructor with Factory Method (Заміна конструктора фабричним методом)


Рисунок Б.13 – Інструменти автоматизації рефакторингу (Visual Studio)


Рисунок Б.14 – Висновок


Рисунок Б.15 – Список використаних джерел



ДОДАТОК В
Програмний код
     GitHub репозиторій: https://github.com/NureNikitinaOleksandra/Boulder-Dash.git
4


